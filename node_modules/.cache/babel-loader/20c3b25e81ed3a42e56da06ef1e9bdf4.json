{"ast":null,"code":"exports.tokenize = initializeDocument;\n\nvar markdownLineEnding = require('../character/markdown-line-ending');\n\nvar createSpace = require('../tokenize/factory-space');\n\nvar blank = require('../tokenize/partial-blank-line');\n\nvar container = {\n  tokenize: tokenizeContainer\n};\nvar lazyFlow = {\n  tokenize: tokenizeLazyFlow\n};\n\nfunction initializeDocument(effects) {\n  var self = this;\n  var stack = [];\n  var continued = 0;\n  var inspectResult;\n  var childFlow;\n  var childToken;\n  return start;\n\n  function start(code) {\n    if (continued < stack.length) {\n      self.containerState = stack[continued][1];\n      return effects.attempt(stack[continued][0].continuation, documentContinue, documentContinued)(code);\n    }\n\n    return documentContinued(code);\n  }\n\n  function documentContinue(code) {\n    continued++;\n    return start(code);\n  }\n\n  function documentContinued(code) {\n    // If we’re in a concrete construct (such as when expecting another line of\n    // HTML, or we resulted in lazy content), we can immediately start flow.\n    if (inspectResult && inspectResult.flowContinue) {\n      return flowStart(code);\n    }\n\n    self.interrupt = childFlow && childFlow.currentConstruct && childFlow.currentConstruct.interruptible;\n    self.containerState = {};\n    return effects.attempt(container, containerContinue, flowStart)(code);\n  }\n\n  function containerContinue(code) {\n    stack.push([self.currentConstruct, self.containerState]);\n    self.containerState = undefined;\n    return documentContinued(code);\n  }\n\n  function flowStart(code) {\n    if (code === null) {\n      exitContainers(0, true);\n      effects.consume(code);\n      return;\n    }\n\n    childFlow = childFlow || self.parser.flow(self.now());\n    effects.enter('chunkFlow', {\n      contentType: 'flow',\n      previous: childToken,\n      _tokenizer: childFlow\n    });\n    return flowContinue(code);\n  }\n\n  function flowContinue(code) {\n    if (code === null) {\n      continueFlow(effects.exit('chunkFlow'));\n      return flowStart(code);\n    }\n\n    if (markdownLineEnding(code)) {\n      effects.consume(code);\n      continueFlow(effects.exit('chunkFlow'));\n      return effects.check({\n        tokenize: tokenizeInspect,\n        partial: true\n      }, documentAfterPeek);\n    }\n\n    effects.consume(code);\n    return flowContinue;\n  }\n\n  function documentAfterPeek(code) {\n    exitContainers(inspectResult.continued, inspectResult && inspectResult.flowEnd);\n    continued = 0;\n    return start(code);\n  }\n\n  function continueFlow(token) {\n    if (childToken) childToken.next = token;\n    childToken = token;\n    childFlow.lazy = inspectResult && inspectResult.lazy;\n    childFlow.defineSkip(token.start);\n    childFlow.write(self.sliceStream(token));\n  }\n\n  function exitContainers(size, end) {\n    var index = stack.length; // Close the flow.\n\n    if (childFlow && end) {\n      childFlow.write([null]);\n      childToken = childFlow = undefined;\n    } // Exit open containers.\n\n\n    while (index-- > size) {\n      self.containerState = stack[index][1];\n      stack[index][0].exit.call(self, effects);\n    }\n\n    stack.length = size;\n  }\n\n  function tokenizeInspect(effects, ok) {\n    var subcontinued = 0;\n    inspectResult = {};\n    return inspectStart;\n\n    function inspectStart(code) {\n      if (subcontinued < stack.length) {\n        self.containerState = stack[subcontinued][1];\n        return effects.attempt(stack[subcontinued][0].continuation, inspectContinue, inspectLess)(code);\n      } // If we’re continued but in a concrete flow, we can’t have more\n      // containers.\n\n\n      if (childFlow.currentConstruct && childFlow.currentConstruct.concrete) {\n        inspectResult.flowContinue = true;\n        return inspectDone(code);\n      }\n\n      self.interrupt = childFlow.currentConstruct && childFlow.currentConstruct.interruptible;\n      self.containerState = {};\n      return effects.attempt(container, inspectFlowEnd, inspectDone)(code);\n    }\n\n    function inspectContinue(code) {\n      subcontinued++;\n      return self.containerState._closeFlow ? inspectFlowEnd(code) : inspectStart(code);\n    }\n\n    function inspectLess(code) {\n      if (childFlow.currentConstruct && childFlow.currentConstruct.lazy) {\n        // Maybe another container?\n        self.containerState = {};\n        return effects.attempt(container, inspectFlowEnd, // Maybe flow, or a blank line?\n        effects.attempt(lazyFlow, inspectFlowEnd, effects.check(blank, inspectFlowEnd, inspectLazy)))(code);\n      } // Otherwise we’re interrupting.\n\n\n      return inspectFlowEnd(code);\n    }\n\n    function inspectLazy(code) {\n      // Act as if all containers are continued.\n      subcontinued = stack.length;\n      inspectResult.lazy = true;\n      inspectResult.flowContinue = true;\n      return inspectDone(code);\n    } // We’re done with flow if we have more containers, or an interruption.\n\n\n    function inspectFlowEnd(code) {\n      inspectResult.flowEnd = true;\n      return inspectDone(code);\n    }\n\n    function inspectDone(code) {\n      inspectResult.continued = subcontinued;\n      self.interrupt = self.containerState = undefined;\n      return ok(code);\n    }\n  }\n}\n\nfunction tokenizeContainer(effects, ok, nok) {\n  return createSpace(effects, effects.attempt(this.parser.constructs.document, ok, nok), 'linePrefix', 4);\n}\n\nfunction tokenizeLazyFlow(effects, ok, nok) {\n  return createSpace(effects, effects.lazy(this.parser.constructs.flow, ok, nok), 'linePrefix', 4);\n}","map":{"version":3,"sources":["/home/boshra/personal/markdown-editor/node_modules/micromark/dist/initialize/document.js"],"names":["exports","tokenize","initializeDocument","markdownLineEnding","require","createSpace","blank","container","tokenizeContainer","lazyFlow","tokenizeLazyFlow","effects","self","stack","continued","inspectResult","childFlow","childToken","start","code","length","containerState","attempt","continuation","documentContinue","documentContinued","flowContinue","flowStart","interrupt","currentConstruct","interruptible","containerContinue","push","undefined","exitContainers","consume","parser","flow","now","enter","contentType","previous","_tokenizer","continueFlow","exit","check","tokenizeInspect","partial","documentAfterPeek","flowEnd","token","next","lazy","defineSkip","write","sliceStream","size","end","index","call","ok","subcontinued","inspectStart","inspectContinue","inspectLess","concrete","inspectDone","inspectFlowEnd","_closeFlow","inspectLazy","nok","constructs","document"],"mappings":"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","sourcesContent":["exports.tokenize = initializeDocument\n\nvar markdownLineEnding = require('../character/markdown-line-ending')\n\nvar createSpace = require('../tokenize/factory-space')\nvar blank = require('../tokenize/partial-blank-line')\n\nvar container = {tokenize: tokenizeContainer}\nvar lazyFlow = {tokenize: tokenizeLazyFlow}\n\nfunction initializeDocument(effects) {\n  var self = this\n  var stack = []\n  var continued = 0\n  var inspectResult\n  var childFlow\n  var childToken\n\n  return start\n\n  function start(code) {\n    if (continued < stack.length) {\n      self.containerState = stack[continued][1]\n      return effects.attempt(\n        stack[continued][0].continuation,\n        documentContinue,\n        documentContinued\n      )(code)\n    }\n\n    return documentContinued(code)\n  }\n\n  function documentContinue(code) {\n    continued++\n    return start(code)\n  }\n\n  function documentContinued(code) {\n    // If we’re in a concrete construct (such as when expecting another line of\n    // HTML, or we resulted in lazy content), we can immediately start flow.\n    if (inspectResult && inspectResult.flowContinue) {\n      return flowStart(code)\n    }\n\n    self.interrupt =\n      childFlow &&\n      childFlow.currentConstruct &&\n      childFlow.currentConstruct.interruptible\n    self.containerState = {}\n    return effects.attempt(container, containerContinue, flowStart)(code)\n  }\n\n  function containerContinue(code) {\n    stack.push([self.currentConstruct, self.containerState])\n    self.containerState = undefined\n    return documentContinued(code)\n  }\n\n  function flowStart(code) {\n    if (code === null) {\n      exitContainers(0, true)\n      effects.consume(code)\n      return\n    }\n\n    childFlow = childFlow || self.parser.flow(self.now())\n\n    effects.enter('chunkFlow', {\n      contentType: 'flow',\n      previous: childToken,\n      _tokenizer: childFlow\n    })\n\n    return flowContinue(code)\n  }\n\n  function flowContinue(code) {\n    if (code === null) {\n      continueFlow(effects.exit('chunkFlow'))\n      return flowStart(code)\n    }\n\n    if (markdownLineEnding(code)) {\n      effects.consume(code)\n      continueFlow(effects.exit('chunkFlow'))\n      return effects.check(\n        {tokenize: tokenizeInspect, partial: true},\n        documentAfterPeek\n      )\n    }\n\n    effects.consume(code)\n    return flowContinue\n  }\n\n  function documentAfterPeek(code) {\n    exitContainers(\n      inspectResult.continued,\n      inspectResult && inspectResult.flowEnd\n    )\n\n    continued = 0\n    return start(code)\n  }\n\n  function continueFlow(token) {\n    if (childToken) childToken.next = token\n    childToken = token\n    childFlow.lazy = inspectResult && inspectResult.lazy\n    childFlow.defineSkip(token.start)\n    childFlow.write(self.sliceStream(token))\n  }\n\n  function exitContainers(size, end) {\n    var index = stack.length\n\n    // Close the flow.\n    if (childFlow && end) {\n      childFlow.write([null])\n      childToken = childFlow = undefined\n    }\n\n    // Exit open containers.\n    while (index-- > size) {\n      self.containerState = stack[index][1]\n      stack[index][0].exit.call(self, effects)\n    }\n\n    stack.length = size\n  }\n\n  function tokenizeInspect(effects, ok) {\n    var subcontinued = 0\n\n    inspectResult = {}\n\n    return inspectStart\n\n    function inspectStart(code) {\n      if (subcontinued < stack.length) {\n        self.containerState = stack[subcontinued][1]\n        return effects.attempt(\n          stack[subcontinued][0].continuation,\n          inspectContinue,\n          inspectLess\n        )(code)\n      }\n\n      // If we’re continued but in a concrete flow, we can’t have more\n      // containers.\n      if (childFlow.currentConstruct && childFlow.currentConstruct.concrete) {\n        inspectResult.flowContinue = true\n        return inspectDone(code)\n      }\n\n      self.interrupt =\n        childFlow.currentConstruct && childFlow.currentConstruct.interruptible\n      self.containerState = {}\n      return effects.attempt(container, inspectFlowEnd, inspectDone)(code)\n    }\n\n    function inspectContinue(code) {\n      subcontinued++\n      return self.containerState._closeFlow\n        ? inspectFlowEnd(code)\n        : inspectStart(code)\n    }\n\n    function inspectLess(code) {\n      if (childFlow.currentConstruct && childFlow.currentConstruct.lazy) {\n        // Maybe another container?\n        self.containerState = {}\n        return effects.attempt(\n          container,\n          inspectFlowEnd,\n          // Maybe flow, or a blank line?\n          effects.attempt(\n            lazyFlow,\n            inspectFlowEnd,\n            effects.check(blank, inspectFlowEnd, inspectLazy)\n          )\n        )(code)\n      }\n\n      // Otherwise we’re interrupting.\n      return inspectFlowEnd(code)\n    }\n\n    function inspectLazy(code) {\n      // Act as if all containers are continued.\n      subcontinued = stack.length\n      inspectResult.lazy = true\n      inspectResult.flowContinue = true\n      return inspectDone(code)\n    }\n\n    // We’re done with flow if we have more containers, or an interruption.\n    function inspectFlowEnd(code) {\n      inspectResult.flowEnd = true\n      return inspectDone(code)\n    }\n\n    function inspectDone(code) {\n      inspectResult.continued = subcontinued\n      self.interrupt = self.containerState = undefined\n      return ok(code)\n    }\n  }\n}\n\nfunction tokenizeContainer(effects, ok, nok) {\n  return createSpace(\n    effects,\n    effects.attempt(this.parser.constructs.document, ok, nok),\n    'linePrefix',\n    4\n  )\n}\n\nfunction tokenizeLazyFlow(effects, ok, nok) {\n  return createSpace(\n    effects,\n    effects.lazy(this.parser.constructs.flow, ok, nok),\n    'linePrefix',\n    4\n  )\n}\n"]},"metadata":{},"sourceType":"script"}