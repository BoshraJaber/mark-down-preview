{"ast":null,"code":"exports.text = initializeFactory('text');\nexports.string = initializeFactory('string');\nexports.resolver = {\n  resolveAll: resolver()\n};\n\nvar assign = require('../constant/assign');\n\nvar shallow = require('../util/shallow');\n\nfunction initializeFactory(field) {\n  return {\n    tokenize: initializeText,\n    resolveAll: resolver(field === 'text' ? resolveAllLineSuffixes : undefined)\n  };\n\n  function initializeText(effects) {\n    var self = this;\n    var constructs = this.parser.constructs[field];\n    var text = effects.attempt(constructs, start, notText);\n    return start;\n\n    function start(code) {\n      return atBreak(code) ? text(code) : notText(code);\n    }\n\n    function notText(code) {\n      if (code === null) {\n        effects.consume(code);\n        return;\n      }\n\n      effects.enter('data');\n      effects.consume(code);\n      return data;\n    }\n\n    function data(code) {\n      if (atBreak(code)) {\n        effects.exit('data');\n        return text(code);\n      } // Data.\n\n\n      effects.consume(code);\n      return data;\n    }\n\n    function atBreak(code) {\n      var list = constructs[code];\n      var index = -1;\n\n      if (code === null) {\n        return true;\n      }\n\n      if (list) {\n        while (++index < list.length) {\n          if (!list[index].previous || list[index].previous.call(self, self.previous)) {\n            return true;\n          }\n        }\n      }\n    }\n  }\n}\n\nfunction resolver(extraResolver) {\n  return resolveAllText;\n\n  function resolveAllText(events, context) {\n    var index = -1;\n    var enter; // A rather boring computation (to merge adjacent `data` events) which\n    // improves mm performance by 29%.\n\n    while (++index <= events.length) {\n      if (enter === undefined) {\n        if (events[index] && events[index][1].type === 'data') {\n          enter = index;\n          index++;\n        }\n      } else if (!events[index] || events[index][1].type !== 'data') {\n        // Don’t do anything if there is one data token.\n        if (index !== enter + 2) {\n          events[enter][1].end = events[index - 1][1].end;\n          events.splice(enter + 2, index - enter - 2);\n          index = enter + 2;\n        }\n\n        enter = undefined;\n      }\n    }\n\n    return extraResolver ? extraResolver(events, context) : events;\n  }\n} // A rather ugly set of instructions which again looks at chunks in the input\n// stream.\n// The reason to do this here is that it is *much* faster to parse in reverse.\n// And that we can’t hook into `null` to split the line suffix before an EOF.\n// To do: figure out if we can make this into a clean utility, or even in core.\n// As it will be useful for GFMs literal autolink extension (and maybe even\n// tables?)\n\n\nfunction resolveAllLineSuffixes(events, context) {\n  var eventIndex = -1;\n  var chunks;\n  var data;\n  var chunk;\n  var index;\n  var bufferIndex;\n  var size;\n  var tabs;\n  var token;\n\n  while (++eventIndex <= events.length) {\n    if ((eventIndex === events.length || events[eventIndex][1].type === 'lineEnding') && events[eventIndex - 1][1].type === 'data') {\n      data = events[eventIndex - 1][1];\n      chunks = context.sliceStream(data);\n      index = chunks.length;\n      bufferIndex = -1;\n      size = 0;\n      tabs = undefined;\n\n      while (index--) {\n        chunk = chunks[index];\n\n        if (typeof chunk === 'string') {\n          bufferIndex = chunk.length;\n\n          while (chunk.charCodeAt(bufferIndex - 1) === 32) {\n            size++;\n            bufferIndex--;\n          }\n\n          if (bufferIndex) break;\n          bufferIndex = -1;\n        } // Number\n        else if (chunk === -2) {\n            tabs = true;\n            size++;\n          } else if (chunk === -1) {// Empty\n          } else {\n            // Replacement character, exit.\n            index++;\n            break;\n          }\n      }\n\n      if (size) {\n        token = {\n          type: eventIndex === events.length || tabs || size < 2 ? 'lineSuffix' : 'hardBreakTrailing',\n          start: {\n            line: data.end.line,\n            column: data.end.column - size,\n            offset: data.end.offset - size,\n            _index: data.start._index + index,\n            _bufferIndex: index ? bufferIndex : data.start._bufferIndex + bufferIndex\n          },\n          end: shallow(data.end)\n        };\n        data.end = shallow(token.start);\n\n        if (data.start.offset === data.end.offset) {\n          assign(data, token);\n        } else {\n          events.splice(eventIndex, 0, ['enter', token, context], ['exit', token, context]);\n          eventIndex += 2;\n        }\n      }\n\n      eventIndex++;\n    }\n  }\n\n  return events;\n}","map":{"version":3,"sources":["/home/boshra/personal/markdown-editor/node_modules/micromark/dist/initialize/text.js"],"names":["exports","text","initializeFactory","string","resolver","resolveAll","assign","require","shallow","field","tokenize","initializeText","resolveAllLineSuffixes","undefined","effects","self","constructs","parser","attempt","start","notText","code","atBreak","consume","enter","data","exit","list","index","length","previous","call","extraResolver","resolveAllText","events","context","type","end","splice","eventIndex","chunks","chunk","bufferIndex","size","tabs","token","sliceStream","charCodeAt","line","column","offset","_index","_bufferIndex"],"mappings":"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","sourcesContent":["exports.text = initializeFactory('text')\nexports.string = initializeFactory('string')\nexports.resolver = {resolveAll: resolver()}\n\nvar assign = require('../constant/assign')\n\nvar shallow = require('../util/shallow')\n\nfunction initializeFactory(field) {\n  return {\n    tokenize: initializeText,\n    resolveAll: resolver(field === 'text' ? resolveAllLineSuffixes : undefined)\n  }\n\n  function initializeText(effects) {\n    var self = this\n    var constructs = this.parser.constructs[field]\n    var text = effects.attempt(constructs, start, notText)\n\n    return start\n\n    function start(code) {\n      return atBreak(code) ? text(code) : notText(code)\n    }\n\n    function notText(code) {\n      if (code === null) {\n        effects.consume(code)\n        return\n      }\n\n      effects.enter('data')\n      effects.consume(code)\n      return data\n    }\n\n    function data(code) {\n      if (atBreak(code)) {\n        effects.exit('data')\n        return text(code)\n      }\n\n      // Data.\n      effects.consume(code)\n      return data\n    }\n\n    function atBreak(code) {\n      var list = constructs[code]\n      var index = -1\n\n      if (code === null) {\n        return true\n      }\n\n      if (list) {\n        while (++index < list.length) {\n          if (\n            !list[index].previous ||\n            list[index].previous.call(self, self.previous)\n          ) {\n            return true\n          }\n        }\n      }\n    }\n  }\n}\n\nfunction resolver(extraResolver) {\n  return resolveAllText\n\n  function resolveAllText(events, context) {\n    var index = -1\n    var enter\n\n    // A rather boring computation (to merge adjacent `data` events) which\n    // improves mm performance by 29%.\n    while (++index <= events.length) {\n      if (enter === undefined) {\n        if (events[index] && events[index][1].type === 'data') {\n          enter = index\n          index++\n        }\n      } else if (!events[index] || events[index][1].type !== 'data') {\n        // Don’t do anything if there is one data token.\n        if (index !== enter + 2) {\n          events[enter][1].end = events[index - 1][1].end\n          events.splice(enter + 2, index - enter - 2)\n          index = enter + 2\n        }\n\n        enter = undefined\n      }\n    }\n\n    return extraResolver ? extraResolver(events, context) : events\n  }\n}\n\n// A rather ugly set of instructions which again looks at chunks in the input\n// stream.\n// The reason to do this here is that it is *much* faster to parse in reverse.\n// And that we can’t hook into `null` to split the line suffix before an EOF.\n// To do: figure out if we can make this into a clean utility, or even in core.\n// As it will be useful for GFMs literal autolink extension (and maybe even\n// tables?)\nfunction resolveAllLineSuffixes(events, context) {\n  var eventIndex = -1\n  var chunks\n  var data\n  var chunk\n  var index\n  var bufferIndex\n  var size\n  var tabs\n  var token\n\n  while (++eventIndex <= events.length) {\n    if (\n      (eventIndex === events.length ||\n        events[eventIndex][1].type === 'lineEnding') &&\n      events[eventIndex - 1][1].type === 'data'\n    ) {\n      data = events[eventIndex - 1][1]\n      chunks = context.sliceStream(data)\n      index = chunks.length\n      bufferIndex = -1\n      size = 0\n      tabs = undefined\n\n      while (index--) {\n        chunk = chunks[index]\n\n        if (typeof chunk === 'string') {\n          bufferIndex = chunk.length\n\n          while (chunk.charCodeAt(bufferIndex - 1) === 32) {\n            size++\n            bufferIndex--\n          }\n\n          if (bufferIndex) break\n          bufferIndex = -1\n        }\n        // Number\n        else if (chunk === -2) {\n          tabs = true\n          size++\n        } else if (chunk === -1) {\n          // Empty\n        } else {\n          // Replacement character, exit.\n          index++\n          break\n        }\n      }\n\n      if (size) {\n        token = {\n          type:\n            eventIndex === events.length || tabs || size < 2\n              ? 'lineSuffix'\n              : 'hardBreakTrailing',\n\n          start: {\n            line: data.end.line,\n            column: data.end.column - size,\n            offset: data.end.offset - size,\n            _index: data.start._index + index,\n            _bufferIndex: index\n              ? bufferIndex\n              : data.start._bufferIndex + bufferIndex\n          },\n\n          end: shallow(data.end)\n        }\n\n        data.end = shallow(token.start)\n\n        if (data.start.offset === data.end.offset) {\n          assign(data, token)\n        } else {\n          events.splice(\n            eventIndex,\n            0,\n            ['enter', token, context],\n            ['exit', token, context]\n          )\n\n          eventIndex += 2\n        }\n      }\n\n      eventIndex++\n    }\n  }\n\n  return events\n}\n"]},"metadata":{},"sourceType":"script"}