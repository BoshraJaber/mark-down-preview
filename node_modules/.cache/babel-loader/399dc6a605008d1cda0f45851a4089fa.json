{"ast":null,"code":"exports.tokenize = tokenizeAttention;\nexports.resolveAll = resolveAllAttention;\n\nvar shallow = require('../util/shallow');\n\nvar chunkedSplice = require('../util/chunked-splice');\n\nvar classifyCharacter = require('../util/classify-character');\n\nvar movePoint = require('../util/move-point');\n\nvar resolveAll = require('../util/resolve-all'); // Take all events and resolve attention to emphasis or strong.\n\n\nfunction resolveAllAttention(events, context) {\n  var index = -1;\n  var open;\n  var group;\n  var text;\n  var openingSequence;\n  var closingSequence;\n  var use;\n  var nextEvents;\n  var offset; // Walk through all events.\n  //\n  // Note: performance of this is fine on an mb of normal markdown, but it’s\n  // a bottleneck for malicious stuff.\n\n  while (++index < events.length) {\n    // Find a token that can close.\n    if (events[index][0] === 'enter' && events[index][1].type === 'attentionSequence' && events[index][1]._close) {\n      open = index; // Now walk back to find an opener.\n\n      while (open--) {\n        // Find a token that can open the closer.\n        if (events[open][0] === 'exit' && events[open][1].type === 'attentionSequence' && events[open][1]._open && // If the markers are the same:\n        context.sliceSerialize(events[open][1]).charCodeAt(0) === context.sliceSerialize(events[index][1]).charCodeAt(0)) {\n          // If the opening can close or the closing can open,\n          // and the close size *is not* a multiple of three,\n          // but the sum of the opening and closing size *is* multiple of three,\n          // then don’t match.\n          if ((events[open][1]._close || events[index][1]._open) && (events[index][1].end.offset - events[index][1].start.offset) % 3 && !((events[open][1].end.offset - events[open][1].start.offset + events[index][1].end.offset - events[index][1].start.offset) % 3)) {\n            continue;\n          } // Number of markers to use from the sequence.\n\n\n          use = events[open][1].end.offset - events[open][1].start.offset > 1 && events[index][1].end.offset - events[index][1].start.offset > 1 ? 2 : 1;\n          openingSequence = {\n            type: use > 1 ? 'strongSequence' : 'emphasisSequence',\n            start: movePoint(shallow(events[open][1].end), -use),\n            end: shallow(events[open][1].end)\n          };\n          closingSequence = {\n            type: use > 1 ? 'strongSequence' : 'emphasisSequence',\n            start: shallow(events[index][1].start),\n            end: movePoint(shallow(events[index][1].start), use)\n          };\n          text = {\n            type: use > 1 ? 'strongText' : 'emphasisText',\n            start: shallow(events[open][1].end),\n            end: shallow(events[index][1].start)\n          };\n          group = {\n            type: use > 1 ? 'strong' : 'emphasis',\n            start: shallow(openingSequence.start),\n            end: shallow(closingSequence.end)\n          };\n          events[open][1].end = shallow(openingSequence.start);\n          events[index][1].start = shallow(closingSequence.end);\n          nextEvents = []; // If there are more markers in the opening, add them before.\n\n          if (events[open][1].end.offset - events[open][1].start.offset) {\n            chunkedSplice(nextEvents, nextEvents.length, 0, [['enter', events[open][1], context], ['exit', events[open][1], context]]);\n          } // Opening.\n\n\n          chunkedSplice(nextEvents, nextEvents.length, 0, [['enter', group, context], ['enter', openingSequence, context], ['exit', openingSequence, context], ['enter', text, context]]); // Between.\n\n          chunkedSplice(nextEvents, nextEvents.length, 0, resolveAll(context.parser.constructs.insideSpan.null, events.slice(open + 1, index), context)); // Closing.\n\n          chunkedSplice(nextEvents, nextEvents.length, 0, [['exit', text, context], ['enter', closingSequence, context], ['exit', closingSequence, context], ['exit', group, context]]); // If there are more markers in the closing, add them after.\n\n          if (events[index][1].end.offset - events[index][1].start.offset) {\n            offset = 2;\n            chunkedSplice(nextEvents, nextEvents.length, 0, [['enter', events[index][1], context], ['exit', events[index][1], context]]);\n          } else {\n            offset = 0;\n          }\n\n          chunkedSplice(events, open - 1, index - open + 3, nextEvents);\n          index = open + nextEvents.length - offset - 2;\n          break;\n        }\n      }\n    }\n  } // Remove remaining sequences.\n\n\n  index = -1;\n\n  while (++index < events.length) {\n    if (events[index][1].type === 'attentionSequence') {\n      events[index][1].type = 'data';\n    }\n  }\n\n  return events;\n}\n\nfunction tokenizeAttention(effects, ok) {\n  var before = classifyCharacter(this.previous);\n  var marker;\n  return start;\n\n  function start(code) {\n    effects.enter('attentionSequence');\n    marker = code;\n    return sequence(code);\n  }\n\n  function sequence(code) {\n    var token;\n    var after;\n    var open;\n    var close;\n\n    if (code === marker) {\n      effects.consume(code);\n      return sequence;\n    }\n\n    token = effects.exit('attentionSequence');\n    after = classifyCharacter(code);\n    open = !after || after === 2 && before;\n    close = !before || before === 2 && after;\n    token._open = marker === 42 ? open : open && (before || !close);\n    token._close = marker === 42 ? close : close && (after || !open);\n    return ok(code);\n  }\n}","map":{"version":3,"sources":["/home/boshra/personal/markdown-editor/node_modules/micromark/dist/tokenize/attention.js"],"names":["exports","tokenize","tokenizeAttention","resolveAll","resolveAllAttention","shallow","require","chunkedSplice","classifyCharacter","movePoint","events","context","index","open","group","text","openingSequence","closingSequence","use","nextEvents","offset","length","type","_close","_open","sliceSerialize","charCodeAt","end","start","parser","constructs","insideSpan","null","slice","effects","ok","before","previous","marker","code","enter","sequence","token","after","close","consume","exit"],"mappings":"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","sourcesContent":["exports.tokenize = tokenizeAttention\nexports.resolveAll = resolveAllAttention\n\nvar shallow = require('../util/shallow')\nvar chunkedSplice = require('../util/chunked-splice')\nvar classifyCharacter = require('../util/classify-character')\nvar movePoint = require('../util/move-point')\nvar resolveAll = require('../util/resolve-all')\n\n// Take all events and resolve attention to emphasis or strong.\nfunction resolveAllAttention(events, context) {\n  var index = -1\n  var open\n  var group\n  var text\n  var openingSequence\n  var closingSequence\n  var use\n  var nextEvents\n  var offset\n\n  // Walk through all events.\n  //\n  // Note: performance of this is fine on an mb of normal markdown, but it’s\n  // a bottleneck for malicious stuff.\n  while (++index < events.length) {\n    // Find a token that can close.\n    if (\n      events[index][0] === 'enter' &&\n      events[index][1].type === 'attentionSequence' &&\n      events[index][1]._close\n    ) {\n      open = index\n\n      // Now walk back to find an opener.\n      while (open--) {\n        // Find a token that can open the closer.\n        if (\n          events[open][0] === 'exit' &&\n          events[open][1].type === 'attentionSequence' &&\n          events[open][1]._open &&\n          // If the markers are the same:\n          context.sliceSerialize(events[open][1]).charCodeAt(0) ===\n            context.sliceSerialize(events[index][1]).charCodeAt(0)\n        ) {\n          // If the opening can close or the closing can open,\n          // and the close size *is not* a multiple of three,\n          // but the sum of the opening and closing size *is* multiple of three,\n          // then don’t match.\n          if (\n            (events[open][1]._close || events[index][1]._open) &&\n            (events[index][1].end.offset - events[index][1].start.offset) % 3 &&\n            !(\n              (events[open][1].end.offset -\n                events[open][1].start.offset +\n                events[index][1].end.offset -\n                events[index][1].start.offset) %\n              3\n            )\n          ) {\n            continue\n          }\n\n          // Number of markers to use from the sequence.\n          use =\n            events[open][1].end.offset - events[open][1].start.offset > 1 &&\n            events[index][1].end.offset - events[index][1].start.offset > 1\n              ? 2\n              : 1\n\n          openingSequence = {\n            type: use > 1 ? 'strongSequence' : 'emphasisSequence',\n            start: movePoint(shallow(events[open][1].end), -use),\n            end: shallow(events[open][1].end)\n          }\n\n          closingSequence = {\n            type: use > 1 ? 'strongSequence' : 'emphasisSequence',\n            start: shallow(events[index][1].start),\n            end: movePoint(shallow(events[index][1].start), use)\n          }\n\n          text = {\n            type: use > 1 ? 'strongText' : 'emphasisText',\n            start: shallow(events[open][1].end),\n            end: shallow(events[index][1].start)\n          }\n\n          group = {\n            type: use > 1 ? 'strong' : 'emphasis',\n            start: shallow(openingSequence.start),\n            end: shallow(closingSequence.end)\n          }\n\n          events[open][1].end = shallow(openingSequence.start)\n          events[index][1].start = shallow(closingSequence.end)\n\n          nextEvents = []\n\n          // If there are more markers in the opening, add them before.\n          if (events[open][1].end.offset - events[open][1].start.offset) {\n            chunkedSplice(nextEvents, nextEvents.length, 0, [\n              ['enter', events[open][1], context],\n              ['exit', events[open][1], context]\n            ])\n          }\n\n          // Opening.\n          chunkedSplice(nextEvents, nextEvents.length, 0, [\n            ['enter', group, context],\n            ['enter', openingSequence, context],\n            ['exit', openingSequence, context],\n            ['enter', text, context]\n          ])\n\n          // Between.\n          chunkedSplice(\n            nextEvents,\n            nextEvents.length,\n            0,\n            resolveAll(\n              context.parser.constructs.insideSpan.null,\n              events.slice(open + 1, index),\n              context\n            )\n          )\n\n          // Closing.\n          chunkedSplice(nextEvents, nextEvents.length, 0, [\n            ['exit', text, context],\n            ['enter', closingSequence, context],\n            ['exit', closingSequence, context],\n            ['exit', group, context]\n          ])\n\n          // If there are more markers in the closing, add them after.\n          if (events[index][1].end.offset - events[index][1].start.offset) {\n            offset = 2\n            chunkedSplice(nextEvents, nextEvents.length, 0, [\n              ['enter', events[index][1], context],\n              ['exit', events[index][1], context]\n            ])\n          } else {\n            offset = 0\n          }\n\n          chunkedSplice(events, open - 1, index - open + 3, nextEvents)\n\n          index = open + nextEvents.length - offset - 2\n          break\n        }\n      }\n    }\n  }\n\n  // Remove remaining sequences.\n  index = -1\n\n  while (++index < events.length) {\n    if (events[index][1].type === 'attentionSequence') {\n      events[index][1].type = 'data'\n    }\n  }\n\n  return events\n}\n\nfunction tokenizeAttention(effects, ok) {\n  var before = classifyCharacter(this.previous)\n  var marker\n\n  return start\n\n  function start(code) {\n    effects.enter('attentionSequence')\n    marker = code\n    return sequence(code)\n  }\n\n  function sequence(code) {\n    var token\n    var after\n    var open\n    var close\n\n    if (code === marker) {\n      effects.consume(code)\n      return sequence\n    }\n\n    token = effects.exit('attentionSequence')\n    after = classifyCharacter(code)\n    open = !after || (after === 2 && before)\n    close = !before || (before === 2 && after)\n    token._open = marker === 42 ? open : open && (before || !close)\n    token._close = marker === 42 ? close : close && (after || !open)\n    return ok(code)\n  }\n}\n"]},"metadata":{},"sourceType":"script"}