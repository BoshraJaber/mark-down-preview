{"ast":null,"code":"exports.tokenize = tokenizeListStart;\nexports.continuation = {\n  tokenize: tokenizeListContinuation\n};\nexports.exit = tokenizeListEnd;\n\nvar markdownSpace = require('../character/markdown-space');\n\nvar asciiDigit = require('../character/ascii-digit');\n\nvar prefixSize = require('../util/prefix-size');\n\nvar sizeChunks = require('../util/size-chunks');\n\nvar thematicBreak = require('./thematic-break');\n\nvar createSpace = require('./factory-space');\n\nvar blank = require('./partial-blank-line');\n\nfunction tokenizeListStart(effects, ok, nok) {\n  var self = this;\n  var initialSize = prefixSize(self.events, 'linePrefix');\n  var valueSize;\n  return start;\n\n  function start(code) {\n    if ((code === 42 || code === 43 || code === 45) && (!self.containerState.marker || code === self.containerState.marker)) {\n      return code === 42 || code === 45 ? effects.check(thematicBreak, nok, unordered)(code) : unordered(code);\n    }\n\n    if (asciiDigit(code) && (!self.containerState.type || self.containerState.type === 'listOrdered')) {\n      return ordered(code);\n    }\n\n    return nok(code);\n  }\n\n  function unordered(code) {\n    if (!self.containerState.type) {\n      self.containerState.type = 'listUnordered';\n      effects.enter(self.containerState.type, {\n        _container: true\n      });\n    }\n\n    effects.enter('listItemPrefix');\n    return atMarker(code);\n  }\n\n  function ordered(code) {\n    if (self.containerState.type || !self.interrupt || code === 49) {\n      if (!self.containerState.type) {\n        self.containerState.type = 'listOrdered';\n        effects.enter(self.containerState.type, {\n          _container: true\n        });\n      }\n\n      effects.enter('listItemPrefix');\n      effects.enter('listItemValue');\n      effects.consume(code);\n      valueSize = 1;\n      return self.interrupt ? afterValue : inside;\n    }\n\n    return nok(code);\n  }\n\n  function inside(code) {\n    if (asciiDigit(code) && ++valueSize < 10) {\n      effects.consume(code);\n      return inside;\n    }\n\n    return afterValue(code);\n  }\n\n  function afterValue(code) {\n    effects.exit('listItemValue');\n    return code === 41 || code === 46 ? atMarker(code) : nok(code);\n  }\n\n  function atMarker(code) {\n    self.containerState.marker = self.containerState.marker || code;\n\n    if (code === self.containerState.marker) {\n      effects.enter('listItemMarker');\n      effects.consume(code);\n      effects.exit('listItemMarker');\n      return effects.check(blank, // Can’t be empty when interrupting.\n      self.interrupt ? nok : onBlank, effects.attempt({\n        tokenize: tokenizeListItemPrefixWhitespace,\n        partial: true\n      }, endOfPrefix, otherPrefix));\n    }\n\n    return nok(code);\n  }\n\n  function onBlank(code) {\n    self.containerState.initialBlankLine = true;\n    initialSize++;\n    return endOfPrefix(code);\n  }\n\n  function otherPrefix(code) {\n    if (markdownSpace(code)) {\n      effects.enter('listItemPrefixWhitespace');\n      effects.consume(code);\n      effects.exit('listItemPrefixWhitespace');\n      return endOfPrefix;\n    }\n\n    return nok(code);\n  }\n\n  function endOfPrefix(code) {\n    self.containerState.size = initialSize + sizeChunks(self.sliceStream(effects.exit('listItemPrefix')));\n    return ok(code);\n  }\n}\n\nfunction tokenizeListContinuation(effects, ok, nok) {\n  var self = this;\n  self.containerState._closeFlow = undefined;\n  return effects.check(blank, onBlank, notBlank);\n\n  function onBlank(code) {\n    self.containerState.furtherBlankLines = self.containerState.furtherBlankLines || self.containerState.initialBlankLine;\n    return ok(code);\n  }\n\n  function notBlank(code) {\n    if (self.containerState.furtherBlankLines || !markdownSpace(code)) {\n      self.containerState.furtherBlankLines = self.containerState.initialBlankLine = undefined;\n      return notInCurrentItem(code);\n    }\n\n    self.containerState.furtherBlankLines = self.containerState.initialBlankLine = undefined;\n    return effects.attempt({\n      tokenize: tokenizeIndent,\n      partial: true\n    }, ok, notInCurrentItem)(code);\n  }\n\n  function notInCurrentItem(code) {\n    // While we do continue, we signal that the flow should be closed.\n    self.containerState._closeFlow = true; // As we’re closing flow, we’re no longer interrupting\n\n    self.interrupt = undefined;\n    return createSpace(effects, effects.attempt(exports, ok, nok), 'linePrefix', 4)(code);\n  }\n}\n\nfunction tokenizeIndent(effects, ok, nok) {\n  var self = this;\n  return createSpace(effects, afterPrefix, 'listItemIndent', self.containerState.size + 1);\n\n  function afterPrefix(code) {\n    return prefixSize(self.events, 'listItemIndent') === self.containerState.size ? ok(code) : nok(code);\n  }\n}\n\nfunction tokenizeListEnd(effects) {\n  effects.exit(this.containerState.type);\n}\n\nfunction tokenizeListItemPrefixWhitespace(effects, ok, nok) {\n  var self = this;\n  return createSpace(effects, afterPrefix, 'listItemPrefixWhitespace', 4 + 1);\n\n  function afterPrefix(code) {\n    return markdownSpace(code) || !prefixSize(self.events, 'listItemPrefixWhitespace') ? nok(code) : ok(code);\n  }\n}","map":{"version":3,"sources":["/home/boshra/personal/markdown-editor/node_modules/micromark/dist/tokenize/list.js"],"names":["exports","tokenize","tokenizeListStart","continuation","tokenizeListContinuation","exit","tokenizeListEnd","markdownSpace","require","asciiDigit","prefixSize","sizeChunks","thematicBreak","createSpace","blank","effects","ok","nok","self","initialSize","events","valueSize","start","code","containerState","marker","check","unordered","type","ordered","enter","_container","atMarker","interrupt","consume","afterValue","inside","onBlank","attempt","tokenizeListItemPrefixWhitespace","partial","endOfPrefix","otherPrefix","initialBlankLine","size","sliceStream","_closeFlow","undefined","notBlank","furtherBlankLines","notInCurrentItem","tokenizeIndent","afterPrefix"],"mappings":"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","sourcesContent":["exports.tokenize = tokenizeListStart\nexports.continuation = {tokenize: tokenizeListContinuation}\nexports.exit = tokenizeListEnd\n\nvar markdownSpace = require('../character/markdown-space')\nvar asciiDigit = require('../character/ascii-digit')\n\nvar prefixSize = require('../util/prefix-size')\nvar sizeChunks = require('../util/size-chunks')\nvar thematicBreak = require('./thematic-break')\nvar createSpace = require('./factory-space')\nvar blank = require('./partial-blank-line')\n\nfunction tokenizeListStart(effects, ok, nok) {\n  var self = this\n  var initialSize = prefixSize(self.events, 'linePrefix')\n  var valueSize\n\n  return start\n\n  function start(code) {\n    if (\n      (code === 42 || code === 43 || code === 45) &&\n      (!self.containerState.marker || code === self.containerState.marker)\n    ) {\n      return code === 42 || code === 45\n        ? effects.check(thematicBreak, nok, unordered)(code)\n        : unordered(code)\n    }\n\n    if (\n      asciiDigit(code) &&\n      (!self.containerState.type || self.containerState.type === 'listOrdered')\n    ) {\n      return ordered(code)\n    }\n\n    return nok(code)\n  }\n\n  function unordered(code) {\n    if (!self.containerState.type) {\n      self.containerState.type = 'listUnordered'\n      effects.enter(self.containerState.type, {_container: true})\n    }\n\n    effects.enter('listItemPrefix')\n    return atMarker(code)\n  }\n\n  function ordered(code) {\n    if (self.containerState.type || !self.interrupt || code === 49) {\n      if (!self.containerState.type) {\n        self.containerState.type = 'listOrdered'\n        effects.enter(self.containerState.type, {_container: true})\n      }\n\n      effects.enter('listItemPrefix')\n      effects.enter('listItemValue')\n      effects.consume(code)\n      valueSize = 1\n      return self.interrupt ? afterValue : inside\n    }\n\n    return nok(code)\n  }\n\n  function inside(code) {\n    if (asciiDigit(code) && ++valueSize < 10) {\n      effects.consume(code)\n      return inside\n    }\n\n    return afterValue(code)\n  }\n\n  function afterValue(code) {\n    effects.exit('listItemValue')\n\n    return code === 41 || code === 46 ? atMarker(code) : nok(code)\n  }\n\n  function atMarker(code) {\n    self.containerState.marker = self.containerState.marker || code\n\n    if (code === self.containerState.marker) {\n      effects.enter('listItemMarker')\n      effects.consume(code)\n      effects.exit('listItemMarker')\n      return effects.check(\n        blank,\n        // Can’t be empty when interrupting.\n        self.interrupt ? nok : onBlank,\n        effects.attempt(\n          {tokenize: tokenizeListItemPrefixWhitespace, partial: true},\n          endOfPrefix,\n          otherPrefix\n        )\n      )\n    }\n\n    return nok(code)\n  }\n\n  function onBlank(code) {\n    self.containerState.initialBlankLine = true\n    initialSize++\n    return endOfPrefix(code)\n  }\n\n  function otherPrefix(code) {\n    if (markdownSpace(code)) {\n      effects.enter('listItemPrefixWhitespace')\n      effects.consume(code)\n      effects.exit('listItemPrefixWhitespace')\n      return endOfPrefix\n    }\n\n    return nok(code)\n  }\n\n  function endOfPrefix(code) {\n    self.containerState.size =\n      initialSize + sizeChunks(self.sliceStream(effects.exit('listItemPrefix')))\n    return ok(code)\n  }\n}\n\nfunction tokenizeListContinuation(effects, ok, nok) {\n  var self = this\n\n  self.containerState._closeFlow = undefined\n\n  return effects.check(blank, onBlank, notBlank)\n\n  function onBlank(code) {\n    self.containerState.furtherBlankLines =\n      self.containerState.furtherBlankLines ||\n      self.containerState.initialBlankLine\n    return ok(code)\n  }\n\n  function notBlank(code) {\n    if (self.containerState.furtherBlankLines || !markdownSpace(code)) {\n      self.containerState.furtherBlankLines = self.containerState.initialBlankLine = undefined\n      return notInCurrentItem(code)\n    }\n\n    self.containerState.furtherBlankLines = self.containerState.initialBlankLine = undefined\n    return effects.attempt(\n      {tokenize: tokenizeIndent, partial: true},\n      ok,\n      notInCurrentItem\n    )(code)\n  }\n\n  function notInCurrentItem(code) {\n    // While we do continue, we signal that the flow should be closed.\n    self.containerState._closeFlow = true\n    // As we’re closing flow, we’re no longer interrupting\n    self.interrupt = undefined\n    return createSpace(\n      effects,\n      effects.attempt(exports, ok, nok),\n      'linePrefix',\n      4\n    )(code)\n  }\n}\n\nfunction tokenizeIndent(effects, ok, nok) {\n  var self = this\n\n  return createSpace(\n    effects,\n    afterPrefix,\n    'listItemIndent',\n\n    self.containerState.size + 1\n  )\n\n  function afterPrefix(code) {\n    return prefixSize(self.events, 'listItemIndent') ===\n      self.containerState.size\n      ? ok(code)\n      : nok(code)\n  }\n}\n\nfunction tokenizeListEnd(effects) {\n  effects.exit(this.containerState.type)\n}\n\nfunction tokenizeListItemPrefixWhitespace(effects, ok, nok) {\n  var self = this\n\n  return createSpace(\n    effects,\n    afterPrefix,\n    'listItemPrefixWhitespace',\n\n    4 + 1\n  )\n\n  function afterPrefix(code) {\n    return markdownSpace(code) ||\n      !prefixSize(self.events, 'listItemPrefixWhitespace')\n      ? nok(code)\n      : ok(code)\n  }\n}\n"]},"metadata":{},"sourceType":"script"}