{"ast":null,"code":"exports.tokenize = tokenizeCodeIndented;\nexports.resolve = resolveCodeIndented;\n\nvar markdownLineEnding = require('../character/markdown-line-ending');\n\nvar chunkedSplice = require('../util/chunked-splice');\n\nvar prefixSize = require('../util/prefix-size');\n\nvar createSpace = require('./factory-space');\n\nvar continuedIndent = {\n  tokenize: tokenizeContinuedIndent,\n  partial: true\n};\n\nfunction resolveCodeIndented(events, context) {\n  var code = {\n    type: 'codeIndented',\n    start: events[0][1].start,\n    end: events[events.length - 1][1].end\n  };\n  chunkedSplice(events, 0, 0, [['enter', code, context]]);\n  chunkedSplice(events, events.length, 0, [['exit', code, context]]);\n  return events;\n}\n\nfunction tokenizeCodeIndented(effects, ok, nok) {\n  var self = this;\n  return createSpace(effects, afterInitial, 'linePrefix', 4 + 1);\n\n  function afterInitial(code) {\n    // Flow checks blank lines first, so we don’t have EOL/EOF.\n    if (prefixSize(self.events, 'linePrefix') < 4) {\n      return nok(code);\n    }\n\n    effects.enter('codeFlowValue');\n    return content(code);\n  }\n\n  function afterPrefix(code) {\n    if (code === null) {\n      return ok(code);\n    }\n\n    if (markdownLineEnding(code)) {\n      return effects.attempt(continuedIndent, afterPrefix, ok)(code);\n    }\n\n    effects.enter('codeFlowValue');\n    return content(code);\n  }\n\n  function content(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('codeFlowValue');\n      return afterPrefix(code);\n    }\n\n    effects.consume(code);\n    return content;\n  }\n}\n\nfunction tokenizeContinuedIndent(effects, ok, nok) {\n  var self = this;\n  return createSpace(effects, afterPrefix, 'linePrefix', 4 + 1);\n\n  function afterPrefix(code) {\n    if (markdownLineEnding(code)) {\n      effects.enter('lineEnding');\n      effects.consume(code);\n      effects.exit('lineEnding');\n      return createSpace(effects, afterPrefix, 'linePrefix', 4 + 1);\n    }\n\n    return prefixSize(self.events, 'linePrefix') < 4 ? nok(code) : ok(code);\n  }\n}","map":{"version":3,"sources":["/home/boshra/personal/markdown-editor/node_modules/micromark/dist/tokenize/code-indented.js"],"names":["exports","tokenize","tokenizeCodeIndented","resolve","resolveCodeIndented","markdownLineEnding","require","chunkedSplice","prefixSize","createSpace","continuedIndent","tokenizeContinuedIndent","partial","events","context","code","type","start","end","length","effects","ok","nok","self","afterInitial","enter","content","afterPrefix","attempt","exit","consume"],"mappings":"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","sourcesContent":["exports.tokenize = tokenizeCodeIndented\nexports.resolve = resolveCodeIndented\n\nvar markdownLineEnding = require('../character/markdown-line-ending')\n\nvar chunkedSplice = require('../util/chunked-splice')\nvar prefixSize = require('../util/prefix-size')\nvar createSpace = require('./factory-space')\n\nvar continuedIndent = {tokenize: tokenizeContinuedIndent, partial: true}\n\nfunction resolveCodeIndented(events, context) {\n  var code = {\n    type: 'codeIndented',\n    start: events[0][1].start,\n    end: events[events.length - 1][1].end\n  }\n\n  chunkedSplice(events, 0, 0, [['enter', code, context]])\n  chunkedSplice(events, events.length, 0, [['exit', code, context]])\n\n  return events\n}\n\nfunction tokenizeCodeIndented(effects, ok, nok) {\n  var self = this\n\n  return createSpace(\n    effects,\n    afterInitial,\n    'linePrefix',\n\n    4 + 1\n  )\n\n  function afterInitial(code) {\n    // Flow checks blank lines first, so we don’t have EOL/EOF.\n\n    if (prefixSize(self.events, 'linePrefix') < 4) {\n      return nok(code)\n    }\n\n    effects.enter('codeFlowValue')\n    return content(code)\n  }\n\n  function afterPrefix(code) {\n    if (code === null) {\n      return ok(code)\n    }\n\n    if (markdownLineEnding(code)) {\n      return effects.attempt(continuedIndent, afterPrefix, ok)(code)\n    }\n\n    effects.enter('codeFlowValue')\n    return content(code)\n  }\n\n  function content(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('codeFlowValue')\n      return afterPrefix(code)\n    }\n\n    effects.consume(code)\n    return content\n  }\n}\n\nfunction tokenizeContinuedIndent(effects, ok, nok) {\n  var self = this\n\n  return createSpace(\n    effects,\n    afterPrefix,\n    'linePrefix',\n\n    4 + 1\n  )\n\n  function afterPrefix(code) {\n    if (markdownLineEnding(code)) {\n      effects.enter('lineEnding')\n      effects.consume(code)\n      effects.exit('lineEnding')\n\n      return createSpace(\n        effects,\n        afterPrefix,\n        'linePrefix',\n\n        4 + 1\n      )\n    }\n\n    return prefixSize(self.events, 'linePrefix') < 4 ? nok(code) : ok(code)\n  }\n}\n"]},"metadata":{},"sourceType":"script"}