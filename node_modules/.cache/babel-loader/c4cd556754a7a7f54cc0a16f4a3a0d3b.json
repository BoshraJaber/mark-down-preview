{"ast":null,"code":"exports.tokenize = tokenizeAtxHeading;\nexports.resolve = resolveAtxHeading;\n\nvar markdownLineEnding = require('../character/markdown-line-ending');\n\nvar markdownLineEndingOrSpace = require('../character/markdown-line-ending-or-space');\n\nvar markdownSpace = require('../character/markdown-space');\n\nvar chunkedSplice = require('../util/chunked-splice');\n\nvar createSpace = require('./factory-space');\n\nfunction resolveAtxHeading(events, context) {\n  var contentEnd = events.length - 2;\n  var contentStart = 3;\n  var content;\n  var text; // Prefix whitespace, part of the opening.\n\n  if (events[contentStart][1].type === 'whitespace') {\n    contentStart += 2;\n  } // Suffix whitespace, part of the closing.\n\n\n  if (contentEnd - 2 > contentStart && events[contentEnd][1].type === 'whitespace') {\n    contentEnd -= 2;\n  }\n\n  if (events[contentEnd][1].type === 'atxHeadingSequence' && (contentStart === contentEnd - 1 || contentEnd - 4 > contentStart && events[contentEnd - 2][1].type === 'whitespace')) {\n    contentEnd -= contentStart + 1 === contentEnd ? 2 : 4;\n  }\n\n  if (contentEnd > contentStart) {\n    content = {\n      type: 'atxHeadingText',\n      start: events[contentStart][1].start,\n      end: events[contentEnd][1].end\n    };\n    text = {\n      type: 'chunkText',\n      start: events[contentStart][1].start,\n      end: events[contentEnd][1].end,\n      contentType: 'text'\n    };\n    chunkedSplice(events, contentStart, contentEnd - contentStart + 1, [['enter', content, context], ['enter', text, context], ['exit', text, context], ['exit', content, context]]);\n  }\n\n  return events;\n}\n\nfunction tokenizeAtxHeading(effects, ok, nok) {\n  var self = this;\n  var size = 0;\n  return start;\n\n  function start(code) {\n    effects.enter('atxHeading');\n    effects.enter('atxHeadingSequence');\n    return fenceOpenInside(code);\n  }\n\n  function fenceOpenInside(code) {\n    if (code === 35 && size++ < 6) {\n      effects.consume(code);\n      return fenceOpenInside;\n    }\n\n    if (code === null || markdownLineEndingOrSpace(code)) {\n      effects.exit('atxHeadingSequence');\n      return self.interrupt ? ok(code) : headingBreak(code);\n    }\n\n    return nok(code);\n  }\n\n  function headingBreak(code) {\n    if (code === 35) {\n      effects.enter('atxHeadingSequence');\n      return sequence(code);\n    }\n\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('atxHeading');\n      return ok(code);\n    }\n\n    if (markdownSpace(code)) {\n      return createSpace(effects, headingBreak, 'whitespace')(code);\n    }\n\n    effects.enter('atxHeadingText');\n    return data(code);\n  }\n\n  function sequence(code) {\n    if (code === 35) {\n      effects.consume(code);\n      return sequence;\n    }\n\n    effects.exit('atxHeadingSequence');\n    return headingBreak(code);\n  }\n\n  function data(code) {\n    if (code === null || code === 35 || markdownLineEndingOrSpace(code)) {\n      effects.exit('atxHeadingText');\n      return headingBreak(code);\n    }\n\n    effects.consume(code);\n    return data;\n  }\n}","map":{"version":3,"sources":["/home/boshra/personal/markdown-editor/node_modules/micromark/dist/tokenize/heading-atx.js"],"names":["exports","tokenize","tokenizeAtxHeading","resolve","resolveAtxHeading","markdownLineEnding","require","markdownLineEndingOrSpace","markdownSpace","chunkedSplice","createSpace","events","context","contentEnd","length","contentStart","content","text","type","start","end","contentType","effects","ok","nok","self","size","code","enter","fenceOpenInside","consume","exit","interrupt","headingBreak","sequence","data"],"mappings":"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","sourcesContent":["exports.tokenize = tokenizeAtxHeading\nexports.resolve = resolveAtxHeading\n\nvar markdownLineEnding = require('../character/markdown-line-ending')\nvar markdownLineEndingOrSpace = require('../character/markdown-line-ending-or-space')\nvar markdownSpace = require('../character/markdown-space')\n\nvar chunkedSplice = require('../util/chunked-splice')\nvar createSpace = require('./factory-space')\n\nfunction resolveAtxHeading(events, context) {\n  var contentEnd = events.length - 2\n  var contentStart = 3\n  var content\n  var text\n\n  // Prefix whitespace, part of the opening.\n  if (events[contentStart][1].type === 'whitespace') {\n    contentStart += 2\n  }\n\n  // Suffix whitespace, part of the closing.\n  if (\n    contentEnd - 2 > contentStart &&\n    events[contentEnd][1].type === 'whitespace'\n  ) {\n    contentEnd -= 2\n  }\n\n  if (\n    events[contentEnd][1].type === 'atxHeadingSequence' &&\n    (contentStart === contentEnd - 1 ||\n      (contentEnd - 4 > contentStart &&\n        events[contentEnd - 2][1].type === 'whitespace'))\n  ) {\n    contentEnd -= contentStart + 1 === contentEnd ? 2 : 4\n  }\n\n  if (contentEnd > contentStart) {\n    content = {\n      type: 'atxHeadingText',\n      start: events[contentStart][1].start,\n      end: events[contentEnd][1].end\n    }\n\n    text = {\n      type: 'chunkText',\n      start: events[contentStart][1].start,\n      end: events[contentEnd][1].end,\n      contentType: 'text'\n    }\n\n    chunkedSplice(events, contentStart, contentEnd - contentStart + 1, [\n      ['enter', content, context],\n      ['enter', text, context],\n      ['exit', text, context],\n      ['exit', content, context]\n    ])\n  }\n\n  return events\n}\n\nfunction tokenizeAtxHeading(effects, ok, nok) {\n  var self = this\n  var size = 0\n\n  return start\n\n  function start(code) {\n    effects.enter('atxHeading')\n    effects.enter('atxHeadingSequence')\n    return fenceOpenInside(code)\n  }\n\n  function fenceOpenInside(code) {\n    if (code === 35 && size++ < 6) {\n      effects.consume(code)\n      return fenceOpenInside\n    }\n\n    if (code === null || markdownLineEndingOrSpace(code)) {\n      effects.exit('atxHeadingSequence')\n      return self.interrupt ? ok(code) : headingBreak(code)\n    }\n\n    return nok(code)\n  }\n\n  function headingBreak(code) {\n    if (code === 35) {\n      effects.enter('atxHeadingSequence')\n      return sequence(code)\n    }\n\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('atxHeading')\n      return ok(code)\n    }\n\n    if (markdownSpace(code)) {\n      return createSpace(effects, headingBreak, 'whitespace')(code)\n    }\n\n    effects.enter('atxHeadingText')\n    return data(code)\n  }\n\n  function sequence(code) {\n    if (code === 35) {\n      effects.consume(code)\n      return sequence\n    }\n\n    effects.exit('atxHeadingSequence')\n    return headingBreak(code)\n  }\n\n  function data(code) {\n    if (code === null || code === 35 || markdownLineEndingOrSpace(code)) {\n      effects.exit('atxHeadingText')\n      return headingBreak(code)\n    }\n\n    effects.consume(code)\n    return data\n  }\n}\n"]},"metadata":{},"sourceType":"script"}