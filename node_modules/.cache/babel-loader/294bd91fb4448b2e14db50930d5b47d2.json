{"ast":null,"code":"exports.tokenize = tokenizeLabelEnd;\nexports.resolveTo = resolveToLabelEnd;\nexports.resolveAll = resolveAllLabelEnd;\n\nvar markdownLineEndingOrSpace = require('../character/markdown-line-ending-or-space');\n\nvar normalizeIdentifier = require('../util/normalize-identifier');\n\nvar chunkedSplice = require('../util/chunked-splice');\n\nvar resolveAll = require('../util/resolve-all');\n\nvar shallow = require('../util/shallow');\n\nvar createDestination = require('./factory-destination');\n\nvar createLabel = require('./factory-label');\n\nvar createWhitespace = require('./factory-whitespace');\n\nvar createTitle = require('./factory-title');\n\nvar resource = {\n  tokenize: tokenizeResource\n};\nvar fullReference = {\n  tokenize: tokenizeFullReference\n};\nvar collapsedReference = {\n  tokenize: tokenizeCollapsedReference\n};\n\nfunction resolveAllLabelEnd(events) {\n  var index = -1;\n  var token;\n\n  while (++index < events.length) {\n    token = events[index][1];\n\n    if (!token._used && (token.type === 'labelImage' || token.type === 'labelLink' || token.type === 'labelEnd')) {\n      // Remove the marker.\n      events.splice(index + 1, token.type === 'labelImage' ? 4 : 2);\n      token.type = 'data';\n      index++;\n    }\n  }\n\n  return events;\n}\n\nfunction resolveToLabelEnd(events, context) {\n  var index = events.length;\n  var offset = 0;\n  var group;\n  var label;\n  var text;\n  var token;\n  var open;\n  var close;\n  var media; // Find an opening.\n\n  while (index--) {\n    token = events[index][1];\n\n    if (open) {\n      // If we see another link, or inactive link label, we’ve been here before.\n      if (token.type === 'link' || token.type === 'labelLink' && token._inactive) {\n        break;\n      } // Mark other link openings as inactive, as we can’t have links in\n      // links.\n\n\n      if (events[index][0] === 'enter' && token.type === 'labelLink') {\n        token._inactive = true;\n      }\n    } else if (close) {\n      if (events[index][0] === 'enter' && (token.type === 'labelImage' || token.type === 'labelLink') && !token._balanced) {\n        open = index;\n\n        if (token.type !== 'labelLink') {\n          offset = 2;\n          break;\n        }\n      }\n    } else if (token.type === 'labelEnd') {\n      close = index;\n    }\n  }\n\n  group = {\n    type: events[open][1].type === 'labelLink' ? 'link' : 'image',\n    start: shallow(events[open][1].start),\n    end: shallow(events[events.length - 1][1].end)\n  };\n  label = {\n    type: 'label',\n    start: shallow(events[open][1].start),\n    end: shallow(events[close][1].end)\n  };\n  text = {\n    type: 'labelText',\n    start: shallow(events[open + offset + 2][1].end),\n    end: shallow(events[close - 2][1].start)\n  };\n  media = [['enter', group, context], ['enter', label, context]]; // Opening marker.\n\n  chunkedSplice(media, media.length, 0, events.slice(open + 1, open + offset + 3)); // Text open.\n\n  chunkedSplice(media, media.length, 0, [['enter', text, context]]); // Between.\n\n  chunkedSplice(media, media.length, 0, resolveAll(context.parser.constructs.insideSpan.null, events.slice(open + offset + 4, close - 3), context)); // Text close, marker close, label close.\n\n  chunkedSplice(media, media.length, 0, [['exit', text, context], events[close - 2], events[close - 1], ['exit', label, context]]); // Reference, resource, or so.\n\n  chunkedSplice(media, media.length, 0, events.slice(close + 1)); // Media close.\n\n  chunkedSplice(media, media.length, 0, [['exit', group, context]]);\n  chunkedSplice(events, open, events.length, media);\n  return events;\n}\n\nfunction tokenizeLabelEnd(effects, ok, nok) {\n  var self = this;\n  var index = self.events.length;\n  var labelStart;\n  var defined; // Find an opening.\n\n  while (index--) {\n    if ((self.events[index][1].type === 'labelImage' || self.events[index][1].type === 'labelLink') && !self.events[index][1]._balanced) {\n      labelStart = self.events[index][1];\n      break;\n    }\n  }\n\n  return start;\n\n  function start(code) {\n    if (!labelStart) {\n      return nok(code);\n    } // It’s a balanced bracket, but contains a link.\n\n\n    if (labelStart._inactive) return balanced(code);\n    defined = self.parser.defined.indexOf(normalizeIdentifier(self.sliceSerialize({\n      start: labelStart.end,\n      end: self.now()\n    }))) > -1;\n    effects.enter('labelEnd');\n    effects.enter('labelMarker');\n    effects.consume(code);\n    effects.exit('labelMarker');\n    effects.exit('labelEnd');\n    return afterLabelEnd;\n  }\n\n  function afterLabelEnd(code) {\n    // Resource: `[asd](fgh)`.\n    if (code === 40) {\n      return effects.attempt(resource, ok, defined ? ok : balanced)(code);\n    } // Collapsed (`[asd][]`) or full (`[asd][fgh]`) reference?\n\n\n    if (code === 91) {\n      return effects.attempt(fullReference, ok, defined ? effects.attempt(collapsedReference, ok, balanced) : balanced)(code);\n    } // Shortcut reference: `[asd]`?\n\n\n    return defined ? ok(code) : balanced(code);\n  }\n\n  function balanced(code) {\n    labelStart._balanced = true;\n    return nok(code);\n  }\n}\n\nfunction tokenizeResource(effects, ok, nok) {\n  return start;\n\n  function start(code) {\n    effects.enter('resource');\n    effects.enter('resourceMarker');\n    effects.consume(code);\n    effects.exit('resourceMarker');\n    return createWhitespace(effects, open);\n  }\n\n  function open(code) {\n    if (code === 41) {\n      return end(code);\n    }\n\n    return createDestination(effects, destinationAfter, nok, 'resourceDestination', 'resourceDestinationLiteral', 'resourceDestinationLiteralMarker', 'resourceDestinationRaw', 'resourceDestinationString', 3)(code);\n  }\n\n  function destinationAfter(code) {\n    return markdownLineEndingOrSpace(code) ? createWhitespace(effects, between)(code) : end(code);\n  }\n\n  function between(code) {\n    if (code === 34 || code === 39 || code === 40) {\n      return createTitle(effects, createWhitespace(effects, end), nok, 'resourceTitle', 'resourceTitleMarker', 'resourceTitleString')(code);\n    }\n\n    return end(code);\n  }\n\n  function end(code) {\n    if (code === 41) {\n      effects.enter('resourceMarker');\n      effects.consume(code);\n      effects.exit('resourceMarker');\n      effects.exit('resource');\n      return ok;\n    }\n\n    return nok(code);\n  }\n}\n\nfunction tokenizeFullReference(effects, ok, nok) {\n  var self = this;\n  return start;\n\n  function start(code) {\n    return createLabel.call(self, effects, afterLabel, nok, 'reference', 'referenceMarker', 'referenceString')(code);\n  }\n\n  function afterLabel(code) {\n    return self.parser.defined.indexOf(normalizeIdentifier(self.sliceSerialize(self.events[self.events.length - 1][1]).slice(1, -1))) < 0 ? nok(code) : ok(code);\n  }\n}\n\nfunction tokenizeCollapsedReference(effects, ok, nok) {\n  return start;\n\n  function start(code) {\n    effects.enter('reference');\n    effects.enter('referenceMarker');\n    effects.consume(code);\n    effects.exit('referenceMarker');\n    return open;\n  }\n\n  function open(code) {\n    if (code === 93) {\n      effects.enter('referenceMarker');\n      effects.consume(code);\n      effects.exit('referenceMarker');\n      effects.exit('reference');\n      return ok;\n    }\n\n    return nok(code);\n  }\n}","map":{"version":3,"sources":["/home/boshra/personal/markdown-editor/node_modules/micromark/dist/tokenize/label-end.js"],"names":["exports","tokenize","tokenizeLabelEnd","resolveTo","resolveToLabelEnd","resolveAll","resolveAllLabelEnd","markdownLineEndingOrSpace","require","normalizeIdentifier","chunkedSplice","shallow","createDestination","createLabel","createWhitespace","createTitle","resource","tokenizeResource","fullReference","tokenizeFullReference","collapsedReference","tokenizeCollapsedReference","events","index","token","length","_used","type","splice","context","offset","group","label","text","open","close","media","_inactive","_balanced","start","end","slice","parser","constructs","insideSpan","null","effects","ok","nok","self","labelStart","defined","code","balanced","indexOf","sliceSerialize","now","enter","consume","exit","afterLabelEnd","attempt","destinationAfter","between","call","afterLabel"],"mappings":"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","sourcesContent":["exports.tokenize = tokenizeLabelEnd\nexports.resolveTo = resolveToLabelEnd\nexports.resolveAll = resolveAllLabelEnd\n\nvar markdownLineEndingOrSpace = require('../character/markdown-line-ending-or-space')\n\nvar normalizeIdentifier = require('../util/normalize-identifier')\nvar chunkedSplice = require('../util/chunked-splice')\nvar resolveAll = require('../util/resolve-all')\nvar shallow = require('../util/shallow')\nvar createDestination = require('./factory-destination')\nvar createLabel = require('./factory-label')\nvar createWhitespace = require('./factory-whitespace')\nvar createTitle = require('./factory-title')\n\nvar resource = {tokenize: tokenizeResource}\nvar fullReference = {tokenize: tokenizeFullReference}\nvar collapsedReference = {tokenize: tokenizeCollapsedReference}\n\nfunction resolveAllLabelEnd(events) {\n  var index = -1\n  var token\n\n  while (++index < events.length) {\n    token = events[index][1]\n\n    if (\n      !token._used &&\n      (token.type === 'labelImage' ||\n        token.type === 'labelLink' ||\n        token.type === 'labelEnd')\n    ) {\n      // Remove the marker.\n      events.splice(index + 1, token.type === 'labelImage' ? 4 : 2)\n      token.type = 'data'\n      index++\n    }\n  }\n\n  return events\n}\n\nfunction resolveToLabelEnd(events, context) {\n  var index = events.length\n  var offset = 0\n  var group\n  var label\n  var text\n  var token\n  var open\n  var close\n  var media\n\n  // Find an opening.\n  while (index--) {\n    token = events[index][1]\n\n    if (open) {\n      // If we see another link, or inactive link label, we’ve been here before.\n      if (\n        token.type === 'link' ||\n        (token.type === 'labelLink' && token._inactive)\n      ) {\n        break\n      }\n\n      // Mark other link openings as inactive, as we can’t have links in\n      // links.\n      if (events[index][0] === 'enter' && token.type === 'labelLink') {\n        token._inactive = true\n      }\n    } else if (close) {\n      if (\n        events[index][0] === 'enter' &&\n        (token.type === 'labelImage' || token.type === 'labelLink') &&\n        !token._balanced\n      ) {\n        open = index\n\n        if (token.type !== 'labelLink') {\n          offset = 2\n          break\n        }\n      }\n    } else if (token.type === 'labelEnd') {\n      close = index\n    }\n  }\n\n  group = {\n    type: events[open][1].type === 'labelLink' ? 'link' : 'image',\n    start: shallow(events[open][1].start),\n    end: shallow(events[events.length - 1][1].end)\n  }\n\n  label = {\n    type: 'label',\n    start: shallow(events[open][1].start),\n    end: shallow(events[close][1].end)\n  }\n\n  text = {\n    type: 'labelText',\n    start: shallow(events[open + offset + 2][1].end),\n    end: shallow(events[close - 2][1].start)\n  }\n\n  media = [\n    ['enter', group, context],\n    ['enter', label, context]\n  ]\n\n  // Opening marker.\n  chunkedSplice(\n    media,\n    media.length,\n    0,\n    events.slice(open + 1, open + offset + 3)\n  )\n\n  // Text open.\n  chunkedSplice(media, media.length, 0, [['enter', text, context]])\n\n  // Between.\n  chunkedSplice(\n    media,\n    media.length,\n    0,\n    resolveAll(\n      context.parser.constructs.insideSpan.null,\n      events.slice(open + offset + 4, close - 3),\n      context\n    )\n  )\n\n  // Text close, marker close, label close.\n  chunkedSplice(media, media.length, 0, [\n    ['exit', text, context],\n    events[close - 2],\n    events[close - 1],\n    ['exit', label, context]\n  ])\n\n  // Reference, resource, or so.\n  chunkedSplice(media, media.length, 0, events.slice(close + 1))\n\n  // Media close.\n  chunkedSplice(media, media.length, 0, [['exit', group, context]])\n\n  chunkedSplice(events, open, events.length, media)\n\n  return events\n}\n\nfunction tokenizeLabelEnd(effects, ok, nok) {\n  var self = this\n  var index = self.events.length\n  var labelStart\n  var defined\n\n  // Find an opening.\n  while (index--) {\n    if (\n      (self.events[index][1].type === 'labelImage' ||\n        self.events[index][1].type === 'labelLink') &&\n      !self.events[index][1]._balanced\n    ) {\n      labelStart = self.events[index][1]\n      break\n    }\n  }\n\n  return start\n\n  function start(code) {\n    if (!labelStart) {\n      return nok(code)\n    }\n\n    // It’s a balanced bracket, but contains a link.\n    if (labelStart._inactive) return balanced(code)\n    defined =\n      self.parser.defined.indexOf(\n        normalizeIdentifier(\n          self.sliceSerialize({start: labelStart.end, end: self.now()})\n        )\n      ) > -1\n    effects.enter('labelEnd')\n    effects.enter('labelMarker')\n    effects.consume(code)\n    effects.exit('labelMarker')\n    effects.exit('labelEnd')\n    return afterLabelEnd\n  }\n\n  function afterLabelEnd(code) {\n    // Resource: `[asd](fgh)`.\n    if (code === 40) {\n      return effects.attempt(resource, ok, defined ? ok : balanced)(code)\n    }\n\n    // Collapsed (`[asd][]`) or full (`[asd][fgh]`) reference?\n    if (code === 91) {\n      return effects.attempt(\n        fullReference,\n        ok,\n        defined ? effects.attempt(collapsedReference, ok, balanced) : balanced\n      )(code)\n    }\n\n    // Shortcut reference: `[asd]`?\n    return defined ? ok(code) : balanced(code)\n  }\n\n  function balanced(code) {\n    labelStart._balanced = true\n    return nok(code)\n  }\n}\n\nfunction tokenizeResource(effects, ok, nok) {\n  return start\n\n  function start(code) {\n    effects.enter('resource')\n    effects.enter('resourceMarker')\n    effects.consume(code)\n    effects.exit('resourceMarker')\n    return createWhitespace(effects, open)\n  }\n\n  function open(code) {\n    if (code === 41) {\n      return end(code)\n    }\n\n    return createDestination(\n      effects,\n      destinationAfter,\n      nok,\n      'resourceDestination',\n      'resourceDestinationLiteral',\n      'resourceDestinationLiteralMarker',\n      'resourceDestinationRaw',\n      'resourceDestinationString',\n      3\n    )(code)\n  }\n\n  function destinationAfter(code) {\n    return markdownLineEndingOrSpace(code)\n      ? createWhitespace(effects, between)(code)\n      : end(code)\n  }\n\n  function between(code) {\n    if (code === 34 || code === 39 || code === 40) {\n      return createTitle(\n        effects,\n        createWhitespace(effects, end),\n        nok,\n        'resourceTitle',\n        'resourceTitleMarker',\n        'resourceTitleString'\n      )(code)\n    }\n\n    return end(code)\n  }\n\n  function end(code) {\n    if (code === 41) {\n      effects.enter('resourceMarker')\n      effects.consume(code)\n      effects.exit('resourceMarker')\n      effects.exit('resource')\n      return ok\n    }\n\n    return nok(code)\n  }\n}\n\nfunction tokenizeFullReference(effects, ok, nok) {\n  var self = this\n\n  return start\n\n  function start(code) {\n    return createLabel.call(\n      self,\n      effects,\n      afterLabel,\n      nok,\n      'reference',\n      'referenceMarker',\n      'referenceString'\n    )(code)\n  }\n\n  function afterLabel(code) {\n    return self.parser.defined.indexOf(\n      normalizeIdentifier(\n        self.sliceSerialize(self.events[self.events.length - 1][1]).slice(1, -1)\n      )\n    ) < 0\n      ? nok(code)\n      : ok(code)\n  }\n}\n\nfunction tokenizeCollapsedReference(effects, ok, nok) {\n  return start\n\n  function start(code) {\n    effects.enter('reference')\n    effects.enter('referenceMarker')\n    effects.consume(code)\n    effects.exit('referenceMarker')\n    return open\n  }\n\n  function open(code) {\n    if (code === 93) {\n      effects.enter('referenceMarker')\n      effects.consume(code)\n      effects.exit('referenceMarker')\n      effects.exit('reference')\n      return ok\n    }\n\n    return nok(code)\n  }\n}\n"]},"metadata":{},"sourceType":"script"}